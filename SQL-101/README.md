# Структура функций SQL
![категории команд](https://github.com/Bupley/datalearn/blob/main/SQL-101/categories_of_commands.png)

# PostgreSQL

## Команды DQL - data query language

### Обычные табличные выражения
 ```
 with january
as
	(select
		*
	from
		songify.plays
	where
		extract(month from play_date)=1)
```
Можно создать несколько таких табличных выражений подряд через запятую, для нового табличного выражения пропуская `WITH`. Они должны располагаться строго перед `SELECT` в основном запросе.
 
### Создание нового столбца с оператором `CASE`
```
SELECT 
		CASE
			WHEN medium ILIKE '%gold%' then 'gold'
			WHEN medium ILIKE '%silver%' then 'silver'
			ELSE NULL
			END AS metal,
		 count(id)
	FROM metropolitan.met
	GROUP BY metal
```
Этот оператор задает для условий после `WHEN` значения, расположенные после `THEN`.Эти значения располагаются в новом столбце, называющимся словом после `END AS` (в данном случае - `metal`).  
Чтобы укоротить код, можно название столбца, по которому идет проверка (в данном случае - `medium`), писать не каждый раз после `WHEN`, а один раз после `CASE`.  
Помимо этого, можно задвавть переменные, чтобы не менять условия в выражении CASE:
```
DECLARE 
	@a TINYINT =5,
	@b VARCHAR(10) = 'Привит!',
	@c BIT
SELECT
	CASE
		WHEN @a > 7  THEN 'ok1'
		WHEN LEN(@b) > 10 THEN 'ok2'
		WHEN @c IS NOT NULL THEN 'ok3'
		ELSE 'shit'
	END AS выражение
```
Переенная задается после слова `DECLARE` и начинается с @, лалее заадется название и тип данных переменной, а так е чему она равна. После оператора `WHEN` задается условие с этой переменной, и поочередно проверяются все три, условия.


### Поиск в значениях столбцов части слова с оператором `ILIKE`
```
WHERE date ILIKE '1600-%'
```
после `ILIKE` в одинарных кавычках указывается искомая комбинация. `%` - указывае на неопределенное количество симоволов, `_` указывает на 1 символ. Их можно ставить до, после, или между буквами или пробелами.

### Подзапросы 
Пишутся обычно после `WHERE` в круглых скобках.
```
WHERE 
	e.personality = (
		SELECT 
			personality
		FROM
			vr_startup.employees
		GROUP BY 
			personality
		ORDER BY
			count(employee_id) DESC
			LIMIT 1)
```
В данном случае, условием было, чтобы в поле `e.personality` содержались значения, полученные в результате выполнения подзапроса в скобках. То есть, в подзапросе должно быть только одно значение (не очень понятно, как он будет работать с несколькими значениями - для этого лучше пользоваться *обычными табличными выражениями*). Но эти подзапросы можно совать и в следующем случае:
```
 SELECT 
 	sport
 FROM 
	 (SELECT
	 	DISTINCT sport
	 FROM 
	 	windows_functions.summer_medals) AS sports
```
то есть - как новая таблица, не указанная в схеме (как **обычные табличные выражения**)

### Разделение на группы с помощью `PARTITION BY`:
```
SELECT 
		 	*,
		 	max(gross_salary) OVER(PARTITION BY department) AS max_salary
		 FROM 
		 	windows_functions.salary
```
составые части:
- `PARTITION BY` - задается столбец, по которому будет проводиться группировка
- `OVER()` - открывается оконная функция

### Вывод первого значения с помощью `FIRST_VALUE()`:

```
SELECT
 	s.*,
	FIRST_VALUE(s.first_name) OVER(PARTITION BY s.department ORDER BY s. gross_salary DESC) AS hi_emp
FROM 
 	windows_functions.salary AS s;
```
, где:
- `OVER()` - открывается оконная функция
- `PARTITION BY` - задается столбец, по которому будет проводиться группировка
- `ORDER BY` - задается столбец, по которому будет проводиться сортировка,
- `FIRST_VALUE()` - задается столбец, значение из которого будет выведено при нахождении наибольшего значения из группы, заданной в `PARTITION BY`

### Вывод последнего значения с помощью `LAST_VALUE()`:
```
SELECT
 	s.*,
	LAST_VALUE (s.first_name) OVER(PARTITION BY s.department ORDER BY s. gross_salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS low_emp
FROM 
 	windows_functions.salary AS s;
```
, где:
- `OVER()` - открывается оконная функция
- `PARTITION BY` - задается столбец, по которому будет проводиться группировка
- `ORDER BY` - задается столбец, по которому будет проводиться сортировка
- `ROWS BETWEEN A AND B` - задает строки, среди которых будет проводиться поиск наименьшего значения.  
Варианты для **A**:
	- `UNBOUNDED PRECEDING` - предыдущие строки, ограниченные группой `PARTITION BY`
	- `1 PRECEDING` - предыдущая одна строка
	- `CURRENT ROW` - текущая строка.
	
  Варианты для **B**:
	- `UNBOUNDED FOLLOWING` - последующие строки, ограниченные группой `PARTITION BY`
	- `1 FOLLOWING` - предыдущая одна строка
	- `CURRENT ROW` - текущая строка.
- `LAST_VALUE()` - задается столбец, значение из которого будет выведено при нахождении наименьшего значения из группы, заданной в `PARTITION BY` и ограниченной `ROWS BETWEEN`

### Расчет нарастающего итога:
```
 SELECT
  	"month",
  	change_in_followers,
  	SUM(change_in_followers) OVER (ORDER BY "month" ASC) AS running_total
 FROM
  	windows_functions.social_media
WHERE 
	username = 'instagram';
```
Агрегатная функция `SUM`, после которой следует `OVER()` (т.е открытие оконной функции), указывает на суммирование всех предыдущих строк. формируя накопительный итог. Можно вместо `SUM` использовать `AVG`. После `ORDER BY` указывается, в каком порядке будет идти суммирование. Можно добавить `PARTITION BY`, которая задаст рамки суммирования.

### Вывод предыдущих/последующихзначений с функциями `LEAD` и `LAG`
```
 SELECT 
  	artist,
  	week,
  	streams_millions - LAG(streams_millions, 1, streams_millions) OVER (PARTITION BY artist ORDER BY "week" ASC) AS streams_change,
FROM 
	windows_functions.streams;
```
, где `LAG()` возвращает значение из столбца в скобках на строчку выше (по умолчанию), при его отсутствии - `NULL`. Поменяв второй параметр, можно изменить на сколько строчек вверх (если с минусом - то вниз) будет вестись поиск. Поменяв третий параметр, можно подставить свое значение. Но, важно чтобы оно совпадало по типу со значением из основного столбца (откуда забирают).  
Важно учитывать направление изменения: при втором параметре больше 0 если в рост, то исходное значение нужно вычитать из `LAG`, если на убывание - то из `LAG` нужно вычитать исходное значение. 

```
 SELECT 
  	artist,
  	week,
  	streams_millions,
  	(LEAD(streams_millions, 1, streams_millions) OVER (PARTITION BY artist ORDER BY "week" ASC) - streams_millions) AS streams_change,
FROM 
	windows_functions.streams;
```
, где `LEAD()` возвращает значение из столбца в скобках на строчку ниже (по умолчанию), при его отсутствии - `NULL`. Поменяв второй параметр, можно изменить на сколько строчек вниз (если с минусом - то вверх) будет вестись поиск. Поменяв третий параметр, можно подставить свое значение. Но, важно чтобы оно совпадало по типу со значением из основного столбца (откуда забирают).  
Важно учитывать направление изменения: при втором параметре больше 0 если в рост, то из `LEAD` нужно вычитать исходное значение, если на убывание - то исходное значение нужно вычитать из `LEAD`.  
Таким образом, функции `LAG` и `LEAD` по сути взаимозаменяемые. 

### Нумерация строк с помощью функции `ROW_NUMBER`
```
SELECT 
  	artist,
  	week,
  	streams_millions,
  	ROW_NUMBER () OVER (ORDER BY streams_millions) AS row_num
FROM 
	windows_functions.streams
```
где `ROW_NUMBER ()` выдает порядковый номер строки, отсориторванный согласно условиям после `OVER()` - группа строк и порядок сортировки. После значения `ORDER BY` указывается столбец, по которому будет проводиться сортировка.

### Нумерация строк с уникальными данными с помощью функции `RANK`
```
SELECT 
  	artist,
  	week,
  	streams_millions,
  	RANK () OVER (ORDER BY streams_millions) AS rank
FROM 
	windows_functions.streams
```
где `RANK ()` выдает порядковый номер строки, содержащий уникальное значение (не повторяющееся с предыдущим значением), отсориторванный согласно условиям после `OVER()` - группа строк и порядок сортировки.  
После значения `ORDER BY` указывается столбец, по которому будет проводиться сортировка. Если значения повторяются, то порядковый номер проставляется таким же, как и предыдущий, а следующий номер начинается, "перескакивая" пропущенное число (или числа).

### Нумерация строк с уникальными данными с помощью функции `DENSE_RANK`
```
SELECT 
	artist,
	week,
	streams_millions,
	DENSE_RANK () OVER (ORDER BY streams_millions) AS dens_rank
FROM 
	windows_functions.streams
```
где `DENSE_RANK ()` выдает порядковый номер строки, содержащий уникальное значение (не повторяющееся с предыдущим значением), отсориторванный согласно условиям после `OVER()` - группа строк и порядок сортировки.  
После значения `ORDER BY` указывается столбец, по которому будет проводиться сортировка. Если значения повторяются, то порядковый номер проставляется таким же, как и предыдущий, а следующий номер начинается со следующего по порядку значения (в этом отличие от `RANK`).

# MicrosoftSQL

Названия баз данных, таблиц и столбцов можно писать без квадратных скобок - они появляются, если их не вводить в ручную, а перетаскивать из трея слева.

## Команды DQL - data query language

### Выбор верхних строк с помощью функции TOP
```
SELECT
	TOP 10 PERCENT WITH TIES *
FROM
	[Sales].[SalesOrderDetail]
ORDER BY
	[OrderQty] DESC;
```
После `TOP` идет количство строк для отображения.
Можно добавить `PERCENT` - тогда это будет число процентов от общего количества строк. Можно добавить `WITH TALES` - в этом случае отразятся все повторяющиеся значения, попадающие в выборку (строк будет больше, чем задано после `TOP`)

### Фильтрация по части слова
В отличие от PostgreSQL, оператор `LIKE` не зависит от регистра, а оператора `ILIKE` не существует в принципе.
```
SELECT
	[JobTitle]
FROM
	[HumanResources].[Employee]
WHERE
	[JobTitle] LIKE '[AD]%';
```
така запись после `LIKE` выдвст все слова. начинающиеся на буквы `A` или `D`. Запись после LIKE типа `'[A-D]%'` выведет все слова, начинащиеся на буквы с `A` по `D`. Запись после LIKE типа `'[^AD]%'` выведет все слова, не начинащиеся на буквы `A` и `D`.

### Операции с датой
```
SELECT
	GETDATE()
```
Возвращает текущую дату и время
```
SELECT
	DATEPART (DAY, '2022-02-24')
```
Возвращает часть даты, в данном случае - день
```
SELECT
	DATEADD (YEAR, 3, '2022-02-24');
```
Возвращает дату, увеличенную на 3 (вторая переменная) года (первая переменная)
```
SELECT
	DATEDIFF(DAY, '2024-01-01', GETDATE());
```
Этот запрос вернет разность между последней (первая переменная) и первой датой (вторая переменная) в днях (первая переменная). Важно дат писать в кавычках, чтобы считалась корректно
```
SELECT
	CONVERT(NVARCHAR(19), GETDATE());
```
Этот запрос вернет текущую дату в формате месяц-день-год ЧЧ:ММ PM/AM. Буква `N` в `NVARCHAR` позволяет отображать кириллицу
```
SELECT
	CONVERT(VARCHAR(10), GETDATE(), 10)​;
```
Этот запрос вернет текущую дату в формате ММ-ДД-ГГ
```
SELECT
	CONVERT(VARCHAR(10), GETDATE(), 103);
```
Этот запрос вернет текущую дату в формате ДД-ММ-ГГГГ. Можно поискать и другие коды, в зависимости от обстоятельств.

### Возврат символа на основе кода
```
SELECT
	CHAR(77) AS CodeToCharacter;
```
Возвращает букву на основе кода после `CHAR`

### Сложение строк
```
SELECT
	CONCAT('Burn', ' into ', 'the hell');​
```
Получится "Burn into the hell!"

```
SELECT
	LEFT ([BirthDate], 4),
	RIGHT ([BirthDate], 2),
	LEN ([NationalIDNumber]),
	REPLACE ([LoginID], 'works', 'walks'),
	REVERSE ([JobTitle]),
	UPPER ([JobTitle]),
	LOWER ([JobTitle])
FROM
	[HumanResources].[Employee]
```
`LEFT` и `RIGHT` позволяют извлесь определенное количество символов (вторая перменная) из столбца (первая переменная).  
`LEN` оцениает длину строк.  
`REPLACE` заменяет один набор букв на другой.  
`REVERSE` переворачивает строку.  
`UPPER` и `LOWER` делают все буквы прописными или строчными.

### Создание и удаление синонимов
Синоним - это постоянный аналог названия столбца. Он очень похож на то, как присваюват временное название столбца после AS, но работает постоянно, а не в рамках одного запроса. Его можно вызывать вместо полного названия структурной единицы (столбец/таблица обычно) для сокращения и упрощения запроса.  
Создание синонима:
```
CREATE SYNONYM
	P1 FOR [Person].[Person];
```
Название синонима указывается после `SYNONYM`, название структурной единицы - после `FOR`. Список присвоенных синонимов располагается в директории `DatabaseName/Synonyms`  
Удаление синонима:
```
DROP SYNONYM P1;
```
### Управление диапазоном выдачи запроса (`FETCH`/`OFFSET`)
```
SELECT
	*
FROM 
	[Production].[Product]
ORDER BY
	[StandardCost] DESC
OFFSET
	20 ROWS
FETCH 
	NEXT 20 ROWS ONLY
```
здесь после `OFFSET` указано, сколько строк нужно отступить, а после `FETCH NEXT`  - сколько нужно показать строк. Важно: такая фильтрация работает только в запросах, где ранее была выполенна сортировка (`ORDER BY`)!

### Исполнение подзапрросов с функциями `CROSS APPLY` и `OUTER APPLY`
```
SELECT
	P.[ProductID],
	P.[Name],
	A.[Quantity]
FROM 
	[Production].[Product] AS P
CROSS APPLY		
	(SELECT
		TOP 3 I.[ProductID],
		I.[LocationID], 
		I.[Quantity]
	FROM 
		[Production].[ProductInventory] AS I
	WHERE
		P.[ProductID]=I.[ProductID]
	ORDER BY 
		[Quantity] DESC) AS A;
```
Команда CROSS APPLY	вызывает декартово произведение таблиц (перемножение строк первой и второй таблицы)  из основного запроса и из подзапроса.

```
SELECT
	P.[ProductID],
	P.[Name],
	A.[Quantity]
FROM 
	[Production].[Product] AS P

OUTER APPLY 
	(SELECT
		TOP 3 I.[ProductID],
		I.[LocationID], 
		I.[Quantity]
	FROM 
		[Production].[ProductInventory] AS I
	WHERE
		P.[ProductID]=I.[ProductID]
	ORDER BY 
		[Quantity] DESC) AS A
```
Команда `OUTER APPLY` вызывает декартово произведение таблиц (перемножение строк первой и второй таблицы)  из основного запроса и из подзапроса. Отличие от `CROSS APPLY`: если не находится пара в ключах, по значение из основной таблицы остается и в столбцах из подзапроса проставляется `NULL`

### Преобразование формата таблицы с функциями `PIVOT`/`UNPIVOT`

Функция PIVOT преобразует заголовки столбцов. Пример таблицы до функции PIVOT:
StudentName | Cousre | Score
-|-|-|
Sally	| English	| 95
Sally	| History	| 82
Edward	| English	| 45
Edward	| History	| 78

Запрос на преобразование:
```
SELECT
	*
FROM
	(SELECT
		[StudentName], -- столбец, который будет группироваться (останется по вертикали)
		[Cousre], -- столбец, чьи значения пойдут в заголовки новых столбцов (будет по горизонтали)
		[Score] -- столбец, чьи значения заполнят таблицу (заполнит ячейки)
	FROM 
		[dbo].[Class]) AS ClassTable
PIVOT
	(SUM ([Score])
		FOR [Cousre] IN ([English], [History])) 
			AS ClassPivot
```
После слова `PIVOT` следует агрегатная функция (`SUM`/`AVG`/`MIN`/`MAX`) и столбец, значения которого будут размещены в ячейках новой таблицы.  
После слова `FOR` прописывается название столбца, который будет использован как новые заголовки, после `IN` - в скобках через запятую названия заголовках, соответствующие уникальным значениям из столбца после `FOR`.  
Результирующая таблица:

StudentName | English | History
-|-|-|
Sally	| 95	| 82
Edward	| 45	| 78

Функция UNPIVOT расклывает таблицу в обратном порядке, чем PIVOT:
```
SELECT
	*
FROM
	(SELECT
		[StudentName],
		[English],
		[History]
	FROM 
		[dbo].[Class_2]) AS ClassTable
UNPIVOT
	([Score]
		FOR [Cousre] IN ([English], [History]))
			AS ClassUnpivot
```
После слова `UNPIVOT` следует название нового столбца, значения которого были размещены в ячейках таблицы.  
После слова `FOR` прописывается название нового столбца, значения в котором сформированы из гаоловков исходной таблицы, после `IN` - в скобках через запятую заголовков, которые нужно преобразовать в значения столбцов.

### Подзапросы
Делятся на:  
**Коррелируемые** - такие,внутри которых естьь ссылка на внеший запрос, например:
```
SELECT
	p.[Name],
	p.[ListPrice],
		(SELECT 
			PM.[Name]
		FROM
			[Production].[ProductModel] AS PM
		WHERE 
			P.[ProductID]=PM.[ProductModelID]) AS model
FROM 
	[Production].[Product] AS p
```
В данном запросе после 2 стролбцов, запрашивамых из таблицы из основного запроса, прописывается в круглых скобках отдельный подзапрос, который по условию после `WHERE` выбирает значение из таблицы в подзапросе.

**Некоррелируемые** - такие, внутри которых нет ссылки на внеший запрос, например:
```
SELECT
soh.[SalesOrderID],
soh.[OrderDate],
soh.[CustomerID]
FROM 
	[Sales].[SalesOrderHeader]AS soh
WHERE
[CustomerID]=(SELECT
				c.[CustomerID]
			FROM 
				[Sales].[Customer] AS c
			JOIN
				[Person].[Person] AS p
			ON
				p.[BusinessEntityID]=c.[PersonID]
			WHERE
				p.[LastName] ='Sullivan'
			AND
				p.[FirstName] = 'Michael')
```
В данном подзапросе нет ссылки на таблицу из основго запроса, а результат отдельного исполнения подзапроса в данном случае - это значение из поля `CustomerID` для искомой комбинации имени и фамилии клиента. Выполнение всего запроса позволяет показать операции по клиенту с найденным в подзапросе ID

**С командой `ALL`** - выдают наибольшее значение из выборки данных в подзапросе
```
SELECT
	[BusinessEntityID],
	[Bonus]
FROM 
	[Sales].[SalesPerson]
WHERE
	[Bonus] > ALL (SELECT
					[Bonus]
				FROM
					[Sales].[SalesPerson]
				WHERE
					[SalesQuota] =250000);
```
Исполнение подзапроса дает столбец с набором значений, а команда `ALL` перед подзапросом - выбирает наибольшее значение из них. В подзапросах нельзя использовать `ORDER BY`. Аналогично логическому оператору `И`.

**С командой `ANY`** - выдают сравнивает значение в запросе с любым из выборки данных в подзапросе.
```
SELECT
	[BusinessEntityID],
	[Bonus]
FROM 
	[Sales].[SalesPerson]
WHERE
	[Bonus] > ANY (SELECT
					[Bonus]
				FROM
					[Sales].[SalesPerson]
				WHERE
					[SalesQuota] =250000);
```
Исполнение подзапроса дает столбец с набором значений, а команда `ANY` перед подзапросом - сравнивает каждое значение из запроса с каждым значением из подзапрсоса. Условие выполняется, если значение из запроса (после `WHERE`/`HAVING`) удовлетворяет хоть одномe значению из подзапроса. Аналогично логическому оператору `ИЛИ`.

**С командой `EXIST`** - ведется построчный поиск выполнения условия (да или нет). Эта команда применима для больших таблиц
```
SELECT
	soh.[SalesOrderID],
	soh.[OrderDate]
FROM 
	[Sales].[SalesOrderHeader] soh
WHERE
	EXISTS (SELECT
				*
			FROM
				[Sales].[SalesPerson] sp
			WHERE
				sp.[SalesYTD] > 300000
			AND
				soh.[SalesPersonID]=sp.[BusinessEntityID])
```

Для небольших выборок можно пользоваться аналогичным оператором `IN`:

```
SELECT
	soh.[SalesOrderID],
	soh.[OrderDate]
FROM 
	[Sales].[SalesOrderHeader] soh
WHERE
	soh.[SalesPersonID] IN (SELECT
				sp.[BusinessEntityID]
			FROM
				[Sales].[SalesPerson] sp
			WHERE
				sp.[SalesYTD] > 300000)
```
**Рекурсивный подзапрос CTE** - подзапрос, котоырй внути себя содержит цикл:
```
WITH cte_numbers (number_day, weekday) AS
(
	SELECT
		0,
		DATENAME (DW, 0)
	UNION ALL 
	SELECT
		number_day + 1,
		DATENAME (DW, number_day+1)
	FROM 
		cte_numbers
	WHERE number_day < 6
)
SELECT 
	number_day,
	weekday
FROM
	cte_numbers;
```
После первого `SELECT` следует стартовое значение таблицы, формируемой в подзапросе. После второго `SELECT` задается алгоритм "набора" данных в таблицу. Число циклов после `WHERE` огранчиено 100.

### Групповые функции
Виды:
- `GROUP BY` - группировать данные по одному набору группировки
- `GROUP BY GROUPING SETS `- группировать данные по нескольким группирующим наборам:
```
GROUP BY GROUPING SETS
(
	(TerritoryGroup),
	(TerritoryGroup, TerritoryName),
	(TerritoryGroup, TerritoryName, ([FirstName] + ' ' +[LastName]))
);
```
Получаемый результат в отличие от обычного `GROUP BY`, дает информацию по промежуточным итогам (подобно сводным таблицам в Excel)

- `GROUP BY CUBE` - принимает список выражений и определяет все возможные наборы группировки из этого ввода
```
GROUP BY CUBE
(
	TerritoryGroup, TerritoryName, ([FirstName] + ' ' +[LastName])
);
```
Это выражение дает все возможные пересечения группируемых столбцов.

`GROUP BY ROLLUP` - применяется для иерархических структур данных (например, location -> country, region, city)
```
GROUP BY ROLLUP
(
	TerritoryGroup, TerritoryName, ([FirstName] + ' ' +[LastName])
);
```
Запись компактней, чем GROUP BY GROUPING SETS, и дает общий итог по всем строкам.

## Команды DDL - data definition language
         
### Переключение на определенную базу данных
```
USE [AdventureWorks2019]
```
Переключает на базу данных, указанную после `USE()`

### Создание таблицы из новых данных
```
CREATE TABLE dbo.Person (
person_id INT  NOT NULL PRIMARY KEY,
lastname VARCHAR(255) NOT NULL ,
firstname VARCHAR (255),
address VARCHAR (255)  NOT NULL FOREIGN KEY,
city VARCHAR (255) DEFAULT 'Moscow',
age TINYINT CONSTRAINT check_age CHECK (Age>100)
);
```
После `CREATE TABLE` указывается название новой таблицы, далее в скобках через запятую перечисляются названия столбцов и тип данных, ограничения (констрейнты - constraints).  
Виды ограничений:
* `NOT NULL` - гарантирует, что столбец не может иметь значение `NULL`
* `UNIQUE` - гарантирует, что все значения в столбце различны (уникальны)
* `PRIMARY KEY` - комбинация `NOT NULL` и `UNIQUE`. Уникально идентифицирует каждую строку в таблице
* `FOREIGN KEY`  - однозначно идентифицирует строку/запись в другой таблице
* `CHECK` - гарантирует, что все значения в столбце удовлетворяют определенному условию
* `DEFAULT` - устанавливает значение по умолчанию для столбца, если значение не указано
Перед ограничением можно задать его название - перед непосредственно самим ограничением указать `CONSTRAINT`и его название. Список названий можно посмотреть в директории: `TableName/constraints`.

### Создание таблицы на основе данных в уже существующей
```
SELECT
	[AddressID],
	[AddressLine1],
	[City]
INTO
	Address_Berlin
FROM 
	[Person].[Address]
WHERE
	city='Berlin'
```
После `SELECT` и перечисления столбцов для вывода прописывается `INTO` и название новой таблицы. После `FROM` - название таблицы, откуда будут идти данные и команды, связанные с фильтрацией данных.

### Добавление или изменение столбцов
```
ALTER TABLE [dbo].[Person]
ADD date_crated DATE;
```
После `ALTER TABLE` - указывается имя изменяемой таблицы
После `ADD` - название нового столбца и тип данных.

Вариант №1
```
ALTER TABLE [dbo].[Person]
ADD PRIMARY KEY (ID);
```
После `ALTER TABLE` - указывается имя изменяемой таблицы.
После `ADD` - название ограничения и в круглых скобках - название столбца. Важно, чтобы при задании `PRIMARY KEY` ограничиваемый столбец уже имел ограничение `NOT NULL`

Вариант №2.
```
ALTER TABLE
	dbo.Student
ALTER COLUMN
	Age INT NOT NULL;
```
После `ALTER TABLE` - указывается имя изменяемой таблицы.
После `ALTER COLUMN` - название ограничиваемого столбца, тип значения и ограничения.

### Удаление таблицы
```
DROP TABLE IF EXISTS dbo.Person;
```

### Триггеры
Команды, которые запускаются при определенных событиях.
```
CREATE TRIGGER Db_level_trg
ON DATABASE
AFTER CREATE_TABLE
AS
	BEGIN
	PRINT 'I WILL BRAKE YOUR ARMS, IF U CREATE ANOTHER TABLE!'
	ROLLBACK TRANSACTION
	END
```
После CREATE TRIGGER идет название триггера. Триггеры будут храниться в папке базы данных, в подпапке `Programmability/Database Triggers`. после слова AFTER следует типовое событие, такое как:
* CREATE_VIEW
* ALTER_VIEW
* DROP_VIEW
* CREATE_TABLE
* DROP_DATABASE
После слова AS прописывается запрос, выполняемый в случае исполнения указанного типа события.

### Временнные таблицы
Задаются как новые таблицы, но перед названием ставится #. Такие таблицы харнятся только в одном рабочем пространстве (где пишем запрос) при переключении ссылка на них уже не работает, при закрытии - таблица удаляется. Эти таблицы нужны для тестирования запросоов пеерд созданием "постоянной" таблицы.

### Вычисляемые столбцы
При создании таблиц можно задавать столбцы как арифметические функции от других столбцов - таким образом формируются вычисляемые столбцы. При этом сделать вычисляемый столбец на основании другого вычисляемого столбца не получится.
CREATE TABLE dbo.Products (
	ProductID INT IDENTITY (1,1) NOT NULL,
	QtyAvalible SMALLINT,
	UnitPrice MONEY,
	IventoryValue AS QtyAvalible*UnitPrice
);
Последний столбец - вычисляемый. Сначала идет название стобца, после оператора `AS` -  арифметические операции со столбцами или сцепка столбцов через `+`. Такие столбцы нельзя изменить через `UPDATE`, `INSERT`, и им не нужно присваивать тип данных.

## Команды DML - data manipulation language

### Добавление строк
```
INSERT INTO [dbo].[Person]
           ([person_id]
           ,[lastname]
           ,[firstname]
           ,[address]
           ,[city]
           ,[date_crated])
VALUES ('1', 'Ivanov', 'Ivan', 'Bannaya, 1', 'Kyiv', '2024-09-30'),
('2', 'Sidorov', 'Viktor', 'Solnechnaya, 15', 'Bryansk', '2024-09-30'),
('3', 'Kozlov', 'Nikolay', 'lenina 3', 'Izhevsk', '2024-09-30'),
('4', 'Minaylo', 'Semen', 'Derbent',NULL, '2024-09-30');
```
Где после `INSERT INTO` идет название таблицы, куда добавляются сроки, далее в круглых скобках - перечисляются через запятую только те столбцы, где данные нужно добавить. Если нужно использовать все столбцы, можно поставить `*`. Далее прописывается команда `VALUES` и в круглях скобках через запятую  перечислются в аналогичном названиям столбцов порядке значения в ячейках. текстовые и значения даты-времени прописываются в одиночных кавычках. Числовые значения можно писать без кавычек.

### Изменение значений в столбцах
```
UPDATE [dbo].[Person]
SET [date_crated] ='2024-09-29'
WHERE [city] IS NULL;
```
После `UPDATE` указывается таблица, в которой будут изменяться данные. Посе `SET` - изменяемый столбец и новое значение. Скорее всего, потребуется одно или несколько условий фильтрации данных после `WHERE` - иначе затрется весь столбец.

### Удаление отдельных строк
```
DELETE 
FROM [dbo].[Person]
WHERE [person_id] IN ('3', '4') 
```
После `FROM` указывается таблица, в которой будут удалены строки. Скорее всего, потребуется одно или несколько условий фильтрации данных после `WHERE` - иначе затреся вся таблица (станет пустой).

### Триггеры
Команды, которые запускаются при определенных событиях.

#### `AFTER` триггеры
Запускаются после того, как произошло определенное событие:
```
CREATE TRIGGER [Sales].[theStore]
ON [Sales].[Store]
AFTER UPDATE
AS
	UPDATE
		[Sales].[Store]
	SET
		[ModifiedDate] = GETDATE()
	FROM
		inserted
	WHERE
		inserted.BusinessEntityID = [Sales].[Store].BusinessEntityID
	SELECT * FROM inserted
GO
```
После слова `TRIGGER` идет назание триггера. которое будет отображаться в папке `Triggers` в директории таблицы, указанной после `ON`. После AFTER указывается вид команды DML, которая и будет инициировать триггер: это могут быть, напрмеир, `INSERT`, `UPDATE`, `DELETE`, но могут быть и другие. После `AS` указывается исполняемый запрос. В данном случае, запрос работает с системной таблицей `inserted`, годе содержится информация о выопленных манипляциях с информацией, за исключением удаления. В такой же таблице `deleted` содержится информация об удаленных данных. Краткая схема, где и что содержится в системных таблицах:  
 ![inserted and deleted](https://github.com/Bupley/datalearn/blob/main/SQL-101/inserted%20and%20deleted.png)  
 Строчка `SELECT * FROM inserted` выводит данные, котоыре хранятся в таблице `inserted`. По другому, кроме как через исполнение триггера, эти таблицы не увидеть.

#### `INSTEAD` триггеры
запускаются вместо того. чтобы выполнить инициирующее событие:
```
CREATE TRIGGER trg_shift
ON [HumanResources].[Shift]
INSTEAD OF DELETE
 AS
	BEGIN
	PRINT 'HANDS OFF!'
	END
GO
```
Структура запроса аналогична AFTER-триггерам, за исключением замены слова `AFTER` на `INSTEAD`.  
В данном запросе между `BEGIN` и `END` прописан составной запрос, который с помощью этих команд заключен в определенный блок. Этот же запрос можно записать через AFTER-триггер, но нужно полсе строчки `PRINT ...` добавить `ROLLBACK TRANSACTION` - эта команда отменит выполненную операцию.

## Процедуры
Процедура (хранимая процедура) - это набор операторов, хранящийся в базе данных и срабатывающий при вызове этой процедуры по имени.
Типы процедур:
- User-defined (определяемые пользователем)
- Temporary (временные)
- System (системные)

У каждой процедуры может не быть параметров, может ыбть один или несколько праметров ввода.  

User-defined процедуры создаются и хранятся в текущей базе данных в директории: /Programmability/Stored Procedures. 
Пример создания процедуры без параметров:
```
CREATE PROCEDURE PersonEmail
AS
SET NOCOUNT ON
SELECT
	P.[FirstName],
	P.[LastName],
	EA.[EmailAddress]
FROM
	[Person].[Person] P
JOIN
	[Person].[EmailAddress] EA
ON
	P.[BusinessEntityID]=EA.[BusinessEntityID];
```
После `CREATE PROCEDURE` прописывается название процедуры. После `AS` следует упакованная в хранимую процедуру совокупность запросов, а фраза `SET NOCOUNT ON` - отключает функцию подсчета количества строк (это ускоряет работу при болших объемах данных).  
Процедура вызывается следующей командой:
```
EXEC PersonEmail
```
В процедуру можно добавить входные и выходные данные, как показано на следующем примере:
```
 CREATE PROCEDURE PersonCounter
@Name VARCHAR (50) = 'Alexandra', @Counter INT OUTPUT
AS
SET NOCOUNT ON
SET @Counter = 
	(SELECT
	COUNT(P.[FirstName])
FROM
	[Person].[Person] P
WHERE
	@Name = P.[FirstName]);
```
После `CREATE PROCEDURE` прописывается название процедуры, далее после `@` прописывается название (или несколько - тогда через запятую) для входных параметров и тип данных, через равно - значение по умолчанию. Для задания выходной переменной прописывается отдельно словов SET и название выходной перменной, после равно и в скобках - операторы для определения выходного параметра.  
Такая процедура вызывается следующими командами:
```
DECLARE @Counter INT
EXEC [dbo].[PersonCounter] 
			'Andy', 
			@Counter OUTPUT
SELECT @Counter
```
В первой строчке после `DECLARE` прописывается название выходной переменной и тип данных. Вторая строка запускает хранимую процедуру с условием (условиями.ю через запятую) после названия исполняемой процеуры. Для выходных переменных после названия параметра с впередистоящим значком `@` прописывается `OUTPUT`. И третья строка, где `SELECT` позволяет вывести переменную на экран.  


В результате исполнения процедуры так же может быть возвращено какое-либо значение:
```
CREATE PROCEDURE MyFirstRerturn
AS
RETURN 12
```
После слова RETURN прописывается выражение, которое будет отображаться в результате запроса на вывод результаат вычисления хранимой функции:

```
DECLARE @MyValue INT
EXEC @MyValue = [dbo].[MyFirstRerturn]
SELECT @MyValue;
```
В первой строчке после `DECLARE` прописывается название переменной и тип данных, которой будет присвоение возвращаемое значение. Вторая строка запускает хранимую процедуру.В третьей строке `SELECT` позволяет вывести результат на экран. 

Процедуры меняются так же командой `ALTER PROCEDURE`, удаляются -`DROP PROCEDURE`

Для задания временной локальной процедуры перед нее названием ставится `#`. Такая процедура не будет работать нигде, кроме данного листа, и сотрется при закрытии. Указав перед названием процедуры `##`, можно задать временную глобальную процедуру, которая будет работать уже а всех прежних и вновь создаваемых листах, но так же исчезнет при закрытии программы. Они хранятся по следующему пути: `System Databases/tempdb/Programmability/StoredProcedures/System storedProcedures`

## Представления
Представление - это "витуальная таблица", котоая не содержит в себе новых данных, а является результатом исполнения запроса к одной или нескольким таблицам.
Подразделяются на три типа:
- *Индексируемые представления (indexed views)*. Новая таблица, собранная из столбцов "первоначальных" таблиц
- *Разделенные представления (partitioned views).* Новая таблица, "склеивающая" несколько исходных таблиц
- *Системные представления (system views).* Метаинформция о данных, пока что хз, зачем она вообще нужна. 

Первые ссылки в гугле не выдали такого разделения, везде под представлениями понимается первый тип.

### Создание представления
```
CREATE VIEW PhonePerson
WITH SCHEMABINDING AS
SELECT
	P.[PersonType],
	P.[FirstName],
	P.[LastName],
	PP.[PhoneNumber]
FROM
	[Person].[Person] AS p
JOIN
	[Person].[PersonPhone] AS PP
ON
	P.[BusinessEntityID]=PP.[BusinessEntityID]
GO
CREATE UNIQUE CLUSTERED INDEX phonePerson
ON PhonePerson (FirstName, LastName, PhoneNumber)
```
После `CREATE VIEW` прописывается название представления. После телеги в `WITH SCHEMABINDING AS` прописывается запрос, который будет автоматически исполняться при отображении представления. Подразумевается, что таким образом информация из исходных таблиц будет попадать в наше представление. Разделитель GO предназначен для принудительного запуска написанного выше запроса.  
После слов `CREATE UNIQUE CLUSTERED INDEX` обычно идет название подзапроса, после `ON` - так же название подзапроса, в скобках - составляющие индекса. ИНдекс простыми словами позволяет быстро отыскать информацию в большой таблице.

### Изменение структуры представления
```
	ALTER VIEW [HumanResources].[EmployeeInfo]
	AS
SELECT
      [LoginID]
      ,[OrganizationLevel]
      ,[HireDate]
FROM [HumanResources].[Employee]
WHERE 
	[HireDate] < '2010-01-01'
```
После слов `ALTER VIEW` идет название представления, после `AS` - запрос, в котором прописываются изменения, вносимые в структуру представления  - будь-то изменения количества столбцов, фильтрация по условиям.

### Изменение данных в представлении
Не совсем понятно, как представдения защищают от изменения данных, н опри этом есть команды, позволяющие менять исходные данные в таблицах!
```
UPDATE
	[HumanResources].[vEmployee]
SET
	[Title] = 'Frau'
WHERE 
	[BusinessEntityID] = 214;
```
После `UPDATE` следует название представления, после `SET` - название столбца для изменения и новое значение, после `WHERE` - условие, при выполнении которого будет внесено изменение.
Важно, что нельзя менять данные, полученныев результате выполения агрегирующих функций.

### Добавление данных в представлении
```
INSERT INTO
	[HumanResources].[vEmployeeDepartmentHistory] ([Department], [GroupName])
VALUES
	('MyTestDepartment', 'MyTestGroup');
```
После `INSERT INTO` идет название представления, в круглых скобках - перечень столбцов, куда будут занесены данные. После `VALUES`  - в круглых скобках через запятую новые данные в соответствующем столбцам порядке.

## Пользовательские функции
 Это группа операторов SQL, которые объединены для выполенния пользовательской задачи. 
```
CREATE FUNCTION ytdsales()
RETURNS MONEY
AS
	BEGIN
		DECLARE @ytdsales MONEY
		SELECT @ytdsales = SUM([SalesYTD]) FROM [Sales].[SalesTerritory]
		RETURN @ytdsales
	END;
```
После `CREATE FUNCTION` следует название пользовательской функции, которые можно посмотреть в директории базы данных по пути `Programmability/Functions`. Здесь представлены скалярные функции (возвращающие число или тект) и табличные (возвращающие тлаблицу).
В скобках после названия функции обычно идут вводные переменные, если их нет - то `()`.
После слова `RETURNS` указывается тип данных, которые будут возвращаться (для таблиц - `TABLE`). 
Между `BEGIN ... END` пропиывается функция, которая будет выполняться. В начале после слова `DECLARE` указывается возвращаемая переменная и тип данных. В конце (перед `END`) прописываем `RETURN` и название возвращаемой переменной.

Для вызова пользоветлькой функции нужно прописать следующе строки:
```
	DECLARE @ytdResults MONEY
	SELECT @ytdResults=[dbo].[ytdsales]()
	PRINT @ytdResults
```
Задаем новую переменную через `DECLARE`, потом после `SELECT` прописываем условие равенства, и командой `PRINT` выводим результат на экран.

Так выглядит пример пользовательской функции с парметром:
```
CREATE FUNCTION ytdGroup(@Group VARCHAR (50))
RETURNS MONEY
AS
	BEGIN
		DECLARE @ytdsales MONEY
		SELECT @ytdsales = SUM([SalesYTD]) FROM [Sales].[SalesTerritory]
		WHERE [Group]=@Group
		RETURN @ytdsales
	END;
```
После названия поьзовательской функции прописываем переменные и тип их данных, далее - после слова `RETURNS` прописываем тип возвращаемых данных, между `BEGIN ... END` прописываем `DECLARE` с объявлением выводимой переменной и типом данных, указываем словом `WHERE` ссылку на нашу введенную перменную. В конце прпоисываем слово `RETURN` и название нашей выводимой переменной.  
Для вызова пользовательской функции с переменной используем следующую команду:
```
	DECLARE @ytdResults MONEY
	SELECT @ytdResults=[dbo].[ytdGroup]('North America')
	PRINT @ytdResults
```
Задаем новую перменную через `DECLARE`, потом после `SELECT` прописываем условие, и командой `PRINT` выводим результат на экран.

Так выглядит пример табличной пользовательской функции с перменной:
```
CREATE FUNCTION TblValueFunc (@TerritoryID INT)
RETURNS TABLE
AS RETURN
	SELECT
		[Name],
		[CountryRegionCode],
		[Group],
		[SalesYTD]
	FROM
		[Sales].[SalesTerritory]
	WHERE
		[TerritoryID]=@TerritoryID
END
GO
```
После названия поьзовательской функции прописываем переменные и тип их данных, далее - после слова `RETURNS` прописываем `TABLE`, после чего прописываем `AS RETURN` и `SELECT`- запрос на вывод таблицы с условием `WHERE`, которое ссылается на переменную. В конце прописываем слово `END`.  
Для вызова табличной пользовательской функции с переменной используем следующую команду:
```		
SELECT
	*
FROM
	[dbo].[TblValueFunc](7)
```
Где вместо таблицы, на которую мы ссылаемся после слова `FROM` нужно указать название пользовательской функции и в скобках - значения переменных.

## Транзакции
Это группа операторов SQL, которые выполнятся одним "пакетом". особенность в том, что при ошибке в выполнении одной из операций можно откатить ввыполнение всего "пакета". 
Пример транзакции:
```
BEGIN TRANSACTION
UPDATE
	[Sales].[CreditCard]
SET
	[ExpYear] = 2025
WHERE 
	[ExpYear] = 2005 AND [CardType] <> 'Vista';
SELECT * FROM [Sales].[CreditCard];
GO
```
После слов `BEGIN TRANSACTION` прописываются зпросы, входящие в транзацию. При исполнении данной команды транзакция считается открытой, при этом изменения еще не внесены.  
Для создания промежуточных точек сохранения используется команда: 
```
SAVE TRANSACTION CP1
```
Где после `SAVE TRANSACTION` идет название точки сохранения.
Транзакцию можно завершить - если ее результат устраивает - командой 
```
COMMIT TRANSACTION
```
А можно откатить транзакцию до начального стостняи или одной из точек сохранения: 
```
ROLLBACK TRANSACTION CP1
```
## Обработка ошибок с помощью операторов `TRY...CATCH`
```
BEGIN TRY
	BEGIN TRANSACTION
	INSERT INTO
		Sales.SalesTerritory
			(Name,
			CountryRegionCode,
			[Group],
			SalesYTD,
			SalesLastYear,
			CostYTD,
			CostLastYear,
			rowguid,
			ModifiedDate)
	VALUES
		('ABCD',
		'US',
		'NA',
		1.00,
		1.00,
		1.00,
		1.00,
		'43689A10-E30B-497F-B0DE-11DE20267FF8',
		GETDATE())
	COMMIT TRANSACTION
END TRY
BEGIN CATCH
	PRINT 'CATCH STATEMENT ENTERED'
	ROLLBACK TRANSACTION
END CATCH
```
Оператор `BEGIN TRY` открывает блок, в котором выполняется основной запрос. По окончании основного запроса прописывается `END TRY`. Если в процессе выполнения запроса происходит ошибка, то выполняютя запросы между строк `BEGIN CATCH ... END CATCH`.