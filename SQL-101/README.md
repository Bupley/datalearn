# Структура функций SQL
![категории команд](https://github.com/Bupley/datalearn/blob/main/SQL-101/categories_of_commands.png)

# PostgreSQL

## Команды DQL - data query language

### Обычные табличные выражения
 ```
 with january
as
	(select
		*
	from
		songify.plays
	where
		extract(month from play_date)=1)
```
Можно создать несколько таких табличных выраженйи подряд через запятую, для нового табличного выражения пропуская `WITH`. Они должны располагаться строго перед `SELECT` в основном запросе.
 
### Создание нового столбца с оператором `CASE`
```
SELECT 
		CASE
			WHEN medium ILIKE '%gold%' then 'gold'
			WHEN medium ILIKE '%silver%' then 'silver'
			ELSE NULL
			END AS metal,
		 count(id)
	FROM metropolitan.met
	GROUP BY metal
```
Этот оператор задает для условий после `WHEN` значения, расположенные после `THEN`.Эти значения располагаются в новом столбце, называющимся словом после `END AS` (в данном случае - `metal`)

### Поиск в значениях столбцов части слова с оператором `ILIKE`
```
WHERE date ILIKE '1600-%'
```
после `ILIKE` в одинарных кавычках указывается искомая комбинация. `%` - указывае на неопределенное количество симоволов, `_` указывает на 1 символ. Их можно ставить до, после, или между буквами или пробелами.

### Подзапросы 
Пишутся обычно после `WHERE` в круглых скобках.
```
WHERE 
	e.personality = (
		SELECT 
			personality
		FROM
			vr_startup.employees
		GROUP BY 
			personality
		ORDER BY
			count(employee_id) DESC
			LIMIT 1)
```
В данном случае, условием было, чтобы в поле `e.personality` содержались значения, полученные в результате выполнения подзапроса в скобках. То есть, в подзапросе должно быть только одно значение (не очень понятно, как он будет работать с несколькими значениями - для этого лучше пользоваться *обычными табличными выражениями*). Но эти подзапросы можно совать и в следующем случае:
```
 SELECT 
 	sport
 FROM 
	 (SELECT
	 	DISTINCT sport
	 FROM 
	 	windows_functions.summer_medals) AS sports
```
то есть - как новая таблица, не указанная в схеме (как **обычные табличные выражения**)

### Разделение на группы с помощью `PARTITION BY`:
```
SELECT 
		 	*,
		 	max(gross_salary) OVER(PARTITION BY department) AS max_salary
		 FROM 
		 	windows_functions.salary
```
составые части:
- `PARTITION BY` - задается столбец, по которому будет проводиться группировка
- `OVER()` - открывается оконная функция

### Вывод первого значения с помощью `FIRST_VALUE()`:

```
SELECT
 	s.*,
	FIRST_VALUE(s.first_name) OVER(PARTITION BY s.department ORDER BY s. gross_salary DESC) AS hi_emp
FROM 
 	windows_functions.salary AS s;
```
, где:
- `OVER()` - открывается оконная функция
- `PARTITION BY` - задается столбец, по которому будет проводиться группировка
- `ORDER BY` - задается столбец, по которому будет проводиться сортировка,
- `FIRST_VALUE()` - задается столбец, значение из которого будет выведено при нахождении наибольшего значения из группы, заданной в `PARTITION BY`

### Вывод последнего значения с помощью `LAST_VALUE()`:
```
SELECT
 	s.*,
	LAST_VALUE (s.first_name) OVER(PARTITION BY s.department ORDER BY s. gross_salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS low_emp
FROM 
 	windows_functions.salary AS s;
```
, где:
- `OVER()` - открывается оконная функция
- `PARTITION BY` - задается столбец, по которому будет проводиться группировка
- `ORDER BY` - задается столбец, по которому будет проводиться сортировка
- `ROWS BETWEEN A AND B` - задает строки, среди которых будет проводиться поиск наименьшего значения.  
Варианты для **A**:
	- `UNBOUNDED PRECEDING` - предыдущие строки, ограниченные группой `PARTITION BY`
	- `1 PRECEDING` - предыдущая одна строка
	- `CURRENT ROW` - текущая строка.
	
  Варианты для **B**:
	- `UNBOUNDED FOLLOWING` - последующие строки, ограниченные группой `PARTITION BY`
	- `1 FOLLOWING` - предыдущая одна строка
	- `CURRENT ROW` - текущая строка.
- `LAST_VALUE()` - задается столбец, значение из которого будет выведено при нахождении наименьшего значения из группы, заданной в `PARTITION BY` и ограниченной `ROWS BETWEEN`

### Расчет нарастающего итога:
```
 SELECT
  	"month",
  	change_in_followers,
  	SUM(change_in_followers) OVER (ORDER BY "month" ASC) AS running_total
 FROM
  	windows_functions.social_media
WHERE 
	username = 'instagram';
```
Агрегатная функция `SUM`, после которой следует `OVER()` (т.е открытие оконной функции), указывает на суммирование всех предыдущих строк. формируя накопительный итог. Можно вместо `SUM` использовать `AVG`. После `ORDER BY` указывается, в каком порядке будет идти суммирование. Можно добавить `PARTITION BY`, которая задаст рамки суммирования.

### Вывод предыдущих/последующихзначений с функциями `LEAD` и `LAG`
```
 SELECT 
  	artist,
  	week,
  	streams_millions - LAG(streams_millions, 1, streams_millions) OVER (PARTITION BY artist ORDER BY "week" ASC) AS streams_change,
FROM 
	windows_functions.streams;
```
, где `LAG()` возвращает значение из столбца в скобках на строчку выше (по умолчанию), при его отсутствии - `NULL`. Поменяв второй параметр, можно изменить на сколько строчек вверх (если с минусом - то вниз) будет вестись поиск. Поменяв третий параметр, можно подставить свое значение. Но, важно чтобы оно совпадало по типу со значением из основного столбца (откуда забирают).  
Важно учитывать направление изменения: при втором параметре больше 0 если в рост, то исходное значение нужно вычитать из `LAG`, если на убывание - то из `LAG` нужно вычитать исходное значение. 

```
 SELECT 
  	artist,
  	week,
  	streams_millions,
  	(LEAD(streams_millions, 1, streams_millions) OVER (PARTITION BY artist ORDER BY "week" ASC) - streams_millions) AS streams_change,
FROM 
	windows_functions.streams;
```
, где `LEAD()` возвращает значение из столбца в скобках на строчку ниже (по умолчанию), при его отсутствии - `NULL`. Поменяв второй параметр, можно изменить на сколько строчек вниз (если с минусом - то вверх) будет вестись поиск. Поменяв третий параметр, можно подставить свое значение. Но, важно чтобы оно совпадало по типу со значением из основного столбца (откуда забирают).  
Важно учитывать направление изменения: при втором параметре больше 0 если в рост, то из `LEAD` нужно вычитать исходное значение, если на убывание - то исходное значение нужно вычитать из `LEAD`.  
Таким образом, функции `LAG` и `LEAD` по сути взаимозаменяемые. 

### Нумерация строк с помощью функции `ROW_NUMBER`
```
SELECT 
  	artist,
  	week,
  	streams_millions,
  	ROW_NUMBER () OVER (ORDER BY streams_millions) AS row_num
FROM 
	windows_functions.streams
```
где `ROW_NUMBER ()` выдает порядковый номер строки, отсориторванный согласно условиям после `OVER()` - группа строк и порядок сортировки. После значения `ORDER BY` указывается столбец, по которому будет проводиться сортировка.

### Нумерация строк с уникальными данными с помощью функции `RANK`
```
SELECT 
  	artist,
  	week,
  	streams_millions,
  	RANK () OVER (ORDER BY streams_millions) AS rank
FROM 
	windows_functions.streams
```
где `RANK ()` выдает порядковый номер строки, содержащий уникальное значение (не повторяющееся с предыдущим значением), отсориторванный согласно условиям после `OVER()` - группа строк и порядок сортировки.  
После значения `ORDER BY` указывается столбец, по которому будет проводиться сортировка. Если значения повторяются, то порядковый номер проставляется таким же, как и предыдущий, а следующий номер начинается, "перескакивая" пропущенное число (или числа).

### Нумерация строк с уникальными данными с помощью функции `DENSE_RANK`
```
SELECT 
	artist,
	week,
	streams_millions,
	DENSE_RANK () OVER (ORDER BY streams_millions) AS dens_rank
FROM 
	windows_functions.streams
```
где `DENSE_RANK ()` выдает порядковый номер строки, содержащий уникальное значение (не повторяющееся с предыдущим значением), отсориторванный согласно условиям после `OVER()` - группа строк и порядок сортировки.  
После значения `ORDER BY` указывается столбец, по которому будет проводиться сортировка. Если значения повторяются, то порядковый номер проставляется таким же, как и предыдущий, а следующий номер начинается со следующего по порядку значения (в этом отличие от `RANK`).

# MicrosoftSQL

Названия баз данных, таблиц и столбцов можно писать без квадратных скобок - они появляются, если их не вводить в ручную, а перетаскивать из трея слева.

## Команды DQL - data query language

### Выбор верхних строк с помощью функции TOP
```
SELECT
	TOP 10 PERCENT WITH TIES *
FROM
	[Sales].[SalesOrderDetail]
ORDER BY
	[OrderQty] DESC;
```
После `TOP` идет количство строк для отображения.
Можно добавить `PERCENT` - тогда это будет число процентов от общего количества строк. Можно добавить `WITH TALES` - в этом случае отразятся все повторяющиеся значения, попадающие в выборку (строк будет больше, чем задано после `TOP`)

### Фильтрация по части слова
В отличие от PostgreSQL, оператор `LIKE` не зависит от регистра, а оператора `ILIKE` не существует в принципе.
```
SELECT
	[JobTitle]
FROM
	[HumanResources].[Employee]
WHERE
	[JobTitle] LIKE '[AD]%';
```
така запись после `LIKE` выдвст все слова. начинающиеся на буквы `A` или `D`. Запись после LIKE типа `'[A-D]%'` выведет все слова, начинащиеся на буквы с `A` по `D`. Запись после LIKE типа `'[^AD]%'` выведет все слова, не начинащиеся на буквы `A` и `D`.

## Команды DDL - data definition language
         
### Переключение на определенную базу данных
```
USE [AdventureWorks2019]
```
Переключает на базу данных, указанную после `USE()`

### Создание таблицы из новых данных
```
CREATE TABLE dbo.Person (
person_id INT,
lastname VARCHAR(255),
firstname VARCHAR (255),
address VARCHAR (255),
city VARCHAR (255)
);
```
После `CREATE TABLE` указывается название новой таблицы, далее в скобках через запятую перечисляются названия столбцов и тип данных, ограничения (констрейнты - constraints).  
Виды ограничений:
* `NOT NULL` - гарантирует, что столбец не может иметь значение `NULL`
* `UNIQUE` - гарантирует, что все значения в столбце различны (уникальны)
* `PRIMARY KEY` - комбинация `NOT NULL` и `UNIQUE`. Уникально идентифицирует каждую строку в таблице
* `FOREIGN KEY`  - однозначно идентифицирует строку/запись в другой таблице
* `CHECK` - гарантирует, что все значения в столбце удовлетворяют определенному условию
* `DEFAULT` - устанавливает значение по умолчанию для столбца, если значение не указано


### Создание таблицы на основе данных в уже существующей
```
SELECT
	[AddressID],
	[AddressLine1],
	[City]
INTO
	Address_Berlin
FROM 
	[Person].[Address]
WHERE
	city='Berlin'
```
После `SELECT` и перечисления столбцов для вывода прописывается `INTO` и название новой таблицы. После `FROM` - название таблицы, откуда будут идти данные и команды, связанные с фильтрацией данных.

### Добавление или изменение столбцов
```
ALTER TABLE [dbo].[Person]
ADD date_crated DATE;
```
После `ALTER TABLE` - указывается имя изменяемой таблицы
После `ADD` - название нового столбца и тип данных.

Вариант №1
```
ALTER TABLE [dbo].[Person]
ADD PRIMARY KEY (ID);
```
После `ALTER TABLE` - указывается имя изменяемой таблицы.
После `ADD` - название ограничения и в круглых скобках - название столбца. Важно, чтобы при задании `PRIMARY KEY` ограничиваемый столбец уже имел ограничение `NOT NULL`

Вариант №2.
```
ALTER TABLE
	dbo.Student
ALTER COLUMN
	Age INT NOT NULL;
```
После `ALTER TABLE` - указывается имя изменяемой таблицы.
После `ALTER COLUMN` - название ограничиваемого столбца, тип значения и ограничения.

### Удаление таблицы
```
DROP TABLE IF EXISTS dbo.Person;
```

## Команды DML - data manipulation language

### Добавление строк
```
INSERT INTO [dbo].[Person]
           ([person_id]
           ,[lastname]
           ,[firstname]
           ,[address]
           ,[city]
           ,[date_crated])
VALUES ('1', 'Ivanov', 'Ivan', 'Bannaya, 1', 'Kyiv', '2024-09-30'),
('2', 'Sidorov', 'Viktor', 'Solnechnaya, 15', 'Bryansk', '2024-09-30'),
('3', 'Kozlov', 'Nikolay', 'lenina 3', 'Izhevsk', '2024-09-30'),
('4', 'Minaylo', 'Semen', 'Derbent',NULL, '2024-09-30');
```
Где после `INSERT INTO` идет название таблицы, куда добавляются сроки, далее в круглых скобках - перечисляются через запятую только те столбцы, где данные нужно добавить. Если нужно использовать все столбцы, можно поставить `*`. Далее прописывается команда `VALUES` и в круглях скобках через запятую  перечислются в аналогичном названиям столбцов порядке значения в ячейках. текстовые и значения даты-времени прописываются в одиночных кавычках. Числовые значения можно писать без кавычек.

### Изменение значений в столбцах
```
UPDATE [dbo].[Person]
SET [date_crated] ='2024-09-29'
WHERE [city] IS NULL;
```
После `UPDATE` указывается таблица, в которой будут изменяться данные. Посе `SET` - изменяемый столбец и новое значение. Скорее всего, потребуется одно или несколько условий фильтрации данных после `WHERE` - иначе затрется весь столбец.

### Удаление отдельных строк
```
DELETE 
FROM [dbo].[Person]
WHERE [person_id] IN ('3', '4') 
```
После `FROM` указывается таблица, в которой будут удалены строки. ПСкорее всего, потребуется одно или несколько условий фильтрации данных после `WHERE` - иначе затреся вся таблица (станет пустой).


